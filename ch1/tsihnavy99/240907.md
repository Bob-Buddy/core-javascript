## 🖊️ 기본 내용

### ✨ **React에서 setState 시 객체의 가변성으로 인해 발생할 수 있는 문제**

<details>
<summary><b>1. 의도치 않은 상태 변경</b></summary>
    
  ```jsx
  class Example extends React.Component {
    state = {
      user: { name: "John", age: 30 }
    };
  
    handleAgeChange = () => {
      const user = this.state.user;
      user.age += 1;// 직접 객체를 변경
      this.setState({ user });// 같은 참조를 사용하여 setState
    };
  
    render() {
      return (
        <div>
          <p>Age: {this.state.user.age}</p>
          <button onClick={this.handleAgeChange}>Increase Age</button>
        </div>
      );
    }
  }
  ```

  이 예시에서 `handleAgeChange` 메소드는 `state.user` 객체를 직접 수정
  
  &emsp;→ React의 불변성 원칙을 위반
  
  React는 얕은 비교를 수행하므로 객체의 참조가 변경되지 않아 리렌더링이 발생하지 않을 수 있음
</details>
<br>

<details>
<summary><b>2. 성능 최적화 실패</b></summary>

  ```jsx
  class ParentComponent extends React.Component {
    state = {
      data: { items: [1, 2, 3] }
    };
  
    addItem = () => {
      const data = this.state.data;
      data.items.push(data.items.length + 1);// 배열을 직접 수정
      this.setState({ data });
    };
  
    render() {
      return (
        <div>
          <ChildComponent data={this.state.data} />
          <button onClick={this.addItem}>Add Item</button>
        </div>
      );
    }
  }
  
  class ChildComponent extends React.PureComponent {
    render() {
      console.log("ChildComponent rendered");
      return <div>{this.props.data.items.join(", ")}</div>;
    }
  }
  ```
  
  이 예시에서 `ChildComponent`는 `PureComponent`를 사용하여 성능을 최적화
  
  `addItem` 메소드가 `data` 객체를 직접 수정해 `ChildComponent`는 `data` prop의 변경을 감지하지 못하고 리렌더링되지 않을 수 있음
</details>
<br>

<details>
<summary><b>3. 비동기 업데이트로 인한 문제</b></summary>
    
  ```jsx
  class AsyncExample extends React.Component {
    state = {
      count: 0,
      data: { value: 0 }
    };
  
    incrementCount = () => {
      this.setState(prevState => ({ count: prevState.count + 1 }));
    };
  
    incrementDataValue = () => {
      const data = this.state.data;
      data.value += 1;// 직접 객체 수정
      this.setState({ data });
    };
  
    handleClick = () => {
      this.incrementCount();
      this.incrementDataValue();
      this.incrementDataValue();
    };
  
    render() {
      return (
        <div>
          <p>Count: {this.state.count}</p>
          <p>Data Value: {this.state.data.value}</p>
          <button onClick={this.handleClick}>Increment</button>
        </div>
      );
    }
  }
  ```
  
  이 예시에서 `handleClick` 메소드는 `count`와 `data.value`를 모두 증가
  
  `data.value`는 객체를 직접 수정해 `incrementDataValue`를 연속적으로 호출해도 `data.value`가 예상대로 증가하지 않을 수 있음
</details>
<br>

***⇒ 항상 새로운 객체나 배열을 생성하여 상태를 업데이트***

```jsx
handleAgeChange = () => {
  this.setState(prevState => ({
    user: { ...prevState.user, age: prevState.user.age + 1 }
  }));
};

// 또는 Immer를 사용할 경우
handleAgeChange = () => {
  this.setState(produce(draft => {
    draft.user.age += 1;
  }));
};
```
<br>

### ✨ **React에서 useState 외에 가변성을 주의해야하는 부분**

<details>
<summary><b>1. props로 전달된 객체나 배열의 직접 수정</b></summary>
    
  ```jsx
  function ChildComponent({ data }) {
    const handleClick = () => {
      // 좋지 않은 방식
      data.someProperty = 'new value';
    };
  
    return <button onClick={handleClick}>Modify Data</button>;
  }
  ```
  
  → 부모 컴포넌트의 상태를 직접 변경해 예측하기 어려운 동작을 유발할 수 있음
</details>
<br>

<details>
<summary><b>2. useEffect 내부에서의 클로저 문제</b></summary>
    
  ```jsx
  function ExampleComponent({ id }) {
    let data = { value: 0 };
  
    useEffect(() => {
      const fetchData = async () => {
        const response = await fetch(`/api/data/${id}`);
        // 문제 발생 가능
        data = await response.json();
      };
  
      fetchData();
    }, [id]);
  
    return <div>{data.value}</div>;
  }
  ```
  
  → `data`는 컴포넌트가 리렌더링될 때마다 재초기화, useEffect 내부에서 변경된 `data`는 렌더링에 반영되지 않음
</details>
<br>

<details>
<summary><b>3. 이벤트 핸들러에서의 상태 변경</b></summary>
    
  ```jsx
  function Counter() {
    let count = 0;
  
    const handleClick = () => {
      // 리렌더링을 트리거 X
      count += 1;
      console.log(count);
    };
  
    return (
      <div>
        <p>Count: {count}</p>
        <button onClick={handleClick}>Increment</button>
      </div>
    );
  }
  ```
  
  → `count`의 값은 증가하지만 컴포넌트는 리렌더링되지 않아 UI에 반영 X
</details>
<br>

<details>
<summary><b>4. 메모이제이션된 값의 변경</b></summary>
    
  ```jsx
  function MemoExample({ data }) {
    const memoizedData = useMemo(() => {
      return { ...data };
    }, []);
  
    // 예상치 못한 결과 발생 가능
    memoizedData.someProperty = 'new value';
  
    return <div>{memoizedData.someProperty}</div>;
  }
  ```
  
  → 메모이제이션된 객체를 직접 수정하면 React의 최적화 메커니즘을 방해할 수 있음
</details>
<br>

이러한 상황들에서 JavaScript의 가변성은 React의 렌더링 모델과 충돌할 수 있으며 예상치 못한 버그를 유발할 수 있음

→ React에서 작업할 때는 항상 불변성을 유지하는 것이 좋음

- 객체나 배열을 수정해야 할 경우 새로운 복사본을 만들어 작업
- 컴포넌트의 상태를 변경할 때는 항상 setState나 useState의 setter 함수 사용
<br>

---
<br>

> 위와 같이 데이터의 가변성은 예상치 못한 문제를 발생시킬 수 있으므로 불변성을 지켜야하는 상황들이 있다 ⇒ **불변 객체 사용**
> 
<br>

---
<br>

### ✨ **불변 객체를 생성하는 라이브러리**

<details>
<summary><b><a href="https://immutable-js.com/">immutable.js</a></b></summary>

  - 장점
    1. 데이터의 갱신이 있을 때, set와 같이 컬렉션을 변경하는 메서드가 대신 **새로운 불변 컬렉션을 반환**
        - 객체의 복사본을 만드는 작업을 수동으로 하지 않기 때문에 spread operation 등을 반복적으로 사용하지 않아도 된다.
        - 코드가 간결해진다.
    2. 컬렉션을 다시 JavaScript 객체로 **깊거나 얕게 다시 변환**할 수 있음
    3. Batching Mutations과 Lazy Seq으로 **성능 최적화**
        - Batching Mutations: 반환하기 전에 데이터의 변화를 여러 번 준다면 변화가 있을 때마다 새로운 불변 컬렉션을 생성하지 않고 반환할 때만 새로운 불변 컬렉션을 생성한다.
            
          ```js
          const result = [].withMutations(function (list) {
            list.push(4).push(5).push(6);
          }); // push를 여러번 했지만 새로운 컬렉션은 하나만 생성
          ```
            
        - Lazy Seq: Seq는 생성 후, 수정이 불가능하며 일단 사용되면 필요한 작업만 수행한다. 즉, 연쇄 작업(filter, map 등...)이 있을 경우 새로운 컬렉션을 생성하지 않고 필요한 만큼만 연산한다.
        - ex: const oddSquares = Seq([1, 2, 3, 4, 5, 6, 7, 8]).filter(x => x % 2 !== 0) // 중간 배열이 생성되지 않는다..map(x => x * x); // filter는 3번만 map은 1번만 호출된다.
  - 단점
      1. JavaScript의 기본 데이터 구조가 아니기 때문에 **초기 학습 비용**이 높다.
      2. JavaScript 객체가 아닌 고유한 컬렉션을 사용하기 때문에 다른 라이브러리로 **마이그레이션할 때 비용**이 많이 든다.
</details>
<br>

<details>
<summary><b><a href="https://github.com/immerjs/immer">immer.js</a></b></summary>

  - 장점
      1. 전용 API나 데이터 구조를 배우지 않아도 된다. (**초기 학습 비용 낮음**)
          - 일반 JavaScript 데이터 구조(객체, 배열 등...)를 사용한다.
      2. **[보일러 플레이트](## "반복적으로 비슷한 형태를 띄는 코드") 감소**
          - 객체의 복사본을 만드는 작업을 수동으로 하지 않기 때문에 spread operation 등을 반복적으로 사용하지 않아도 된다.
          - 코드가 간결해진다.
      3. **JSON 패치 지원**
  - 단점
      1. class 인스턴스와 같은 객체를 지원하지 않는다.
</details>
<br>

<details>
<summary><b><a href="https://github.com/Yomguithereal/baobab">baobab.js</a></b> (마지막 업데이트가 상당히 오래전)</summary>

  [baobab-react](https://github.com/Yomguithereal/baobab-react)
  ```bash
  $ npm install baobab-react
  ```
</details>
<br>

---
<br>

### ✨ 불변 객체를 만드는 방법

<details>
<summary><b>1. Object.freeze()</b></summary>
    
  ```jsx
  const freezeObject = () => {
    const obj = { name: "John", age: 30, address: { city: "New York" } };
    return Object.freeze(obj);
  };
  ```
  
  - 장점
      - 간단하고 직관적
      - 기본 제공 메서드로 추가 라이브러리 불필요
  - 단점:
      - 얕은(shallow) 동결만 수행 (중첩 객체는 동결되지 않음)
      - 성능 면에서 비용이 높을 수 있음 (특히 큰 객체의 경우)
</details>
<br>

<details>
<summary><b>2. 깊은 복사</b></summary>
  
  ```jsx
  const deepCopy = (obj) => {
    if (typeof obj !== 'object' || obj === null) return obj;
    const newObj = Array.isArray(obj) ? [] : {};
    for (let key in obj) {
      newObj[key] = deepCopy(obj[key]);
    }
    return newObj;
  }
  ```
  
  - 장점
      - 원본 객체와 완전히 분리된 새 객체 생성
      - 중첩 객체도 처리 가능
  - 단점
      - 큰 객체의 경우 메모리 사용량과 성능 비용이 높음
      - **순환 참조**가 있는 객체 처리 시 주의 필요
        <details>
          <summary>순환 참조 예제</summary>
              
          ```jsx
          // 순환 참조 예제
          let objA = { name: "Object A" };
          let objB = { name: "Object B" };
          
          objA.ref = objB;
          objB.ref = objA;
          
          console.log(objA.ref.ref.name); // "Object A"
          
          // 순환 참조가 있는 객체의 깊은 복사 시도 (문제 발생)
          function unsafeDeepCopy(obj) {
              if (typeof obj !== 'object' || obj === null) return obj;
              const newObj = Array.isArray(obj) ? [] : {};
              for (let key in obj) {
                  newObj[key] = unsafeDeepCopy(obj[key]);
              }
              return newObj;
          }
          
          // 다음 코드는 무한 재귀로 인한 스택 오버플로우 오류를 발생시킵니다
          // let copy = unsafeDeepCopy(objA);
          
          // 순환 참조를 처리할 수 있는 안전한 깊은 복사 함수
          function safeDeepCopy(obj, hash = new WeakMap()) {
              if (typeof obj !== 'object' || obj === null) return obj;
              if (hash.has(obj)) return hash.get(obj);
          
              const newObj = Array.isArray(obj) ? [] : {};
              hash.set(obj, newObj);
          
              for (let key in obj) {
                  newObj[key] = safeDeepCopy(obj[key], hash);
              }
          
              return newObj;
          }
          
          // 안전하게 깊은 복사 수행
          let safeCopy = safeDeepCopy(objA);
          console.log(safeCopy.ref.ref.name); // "Object A"
          ```
        </details>
</details>
<br>

<details>
<summary><b>3. getter만 사용</b></summary>
  
  ```jsx
  const getterOnlyObject = {
    get name() { return "John"; },
    get age() { return 30; }
  };
  ```
  
  - 장점
      - 속성별로 세밀한 제어 가능
      - 동적 값 계산 가능
  - 단점
      - 모든 속성에 대해 게터를 정의해야 함
      - 중첩 객체 처리가 복잡해질 수 있음
</details>
<br>

<details>
<summary><b>4. 불변 데이터 구조 (함수형 접근)</b></summary>
  
  ```jsx
  const createImmutableObject = (data) => ({
    get: (key) => data[key],
    set: (key, value) => createImmutableObject({...data, [key]: value})
  });
  ```
  
  - 장점
      - 불변성을 보장하면서 유연한 업데이트 가능
      - 함수형 프로그래밍 패러다임과 잘 어울림
  - 단점
      - 구현이 복잡할 수 있음
      - 기존 코드와의 통합이 어려울 수 있음
</details>
<br>

<details>
<summary><b><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><span title="특정 객체를 감싸 프로퍼티 읽기, 쓰기와 같은 객체에 가해지는 작업을 중간에서 가로채는 객체">Proxy</span></a>를 사용한 불변 객체</b></summary>
  
  ```jsx
  const createImmutableProxy = (target) => {
    return new Proxy(target, {
      set: () => {
        throw new Error("Cannot modify immutable object");
      },
      get: (target, prop) => {
        if (typeof target[prop] === 'object' && target[prop] !== null) {
          return createImmutableProxy(target[prop]);
        }
        return target[prop];
      }
    });
  };
  ```
  
  - 장점
      - 동적으로 불변성 강제 가능
      - 중첩 객체도 자동으로 처리
  - 단점
      - 성능 오버헤드가 있을 수 있음
      - 브라우저 호환성 고려 필요
</details>
<br>

### ✨ 중첩 객체에 대해 불변 객체를 생성하는 방법
<details>
<summary><b>1. 재귀적 Object.freeze() (deepFreeze)</b></summary>
  
  ```jsx
  const deepFreeze = (obj) => {
    Object.keys(obj).forEach(prop => {
      if (typeof obj[prop] === 'object' && !Object.isFrozen(obj[prop])) 
        deepFreeze(obj[prop]);
    });
    return Object.freeze(obj);
  };
  
  // 사용 예
  const obj = { a: 1, b: { c: 2 } };
  const immutableObj = deepFreeze(obj);
  ```
  
  - 모든 중첩 레벨의 객체에 대해 freeze를 적용
  - 단, 이미 생성된 객체의 불변성만 보장하며, 새로운 객체 생성 시에는 별도 처리 필요
</details>
<br>

<details>
<summary><b>2. 불변 업데이트 패턴</b></summary>
  
  ```jsx
  const updateNestedImmutable = (obj, path, value) => {
    if (path.length === 1) {
      return { ...obj, [path[0]]: value };
    }
    return {
      ...obj,
      [path[0]]: updateNestedImmutable(obj[path[0]], path.slice(1), value)
    };
  };
  ```
  
  - 객체의 일부를 업데이트할 때 새로운 객체를 생성
  - 중첩된 경로를 따라 필요한 부분만 복사하고 나머지는 참조를 유지
</details>
<br>

<details>
<summary><b>3. Immutable.js나 Immer 같은 라이브러리 사용</b></summary>

  - 더 효율적이고 편리한 불변 데이터 구조 제공
  - 단, 외부 의존성이 생기고 학습 곡선이 있을 수 있음
</details>
<br>

---
<br>

### ✨ 얕은 복사

&emsp;→ 기본형 데이터는 그대로 복사, 참조형 데이터는 주소만 복사

&emsp;→ 스프레드, slice(), assign() 등 내장함수 O
<br>

### ✨ 깊은 복사

&emsp;→ 모든 하위의 참조형 데이터(중첩 포함) 값을 복사(재귀적 수행 필요)

&emsp;→ 내장함수 X (라이브러리나 별도 함수 사용)

<br>

---
<br>

## 🖊️ 꼬리질문
### ✨ 꼬리질문1 - 얕은복사와 깊은복사

<aside>

***Q***. js의 스프레드 연산자와 slice()대해 자세히 알려줘

***A***. 스프레드 연산자는 배열이나 객체를 펼치는 역할, slice()는 배열의 특정 부분을 새로운 배열로 반환한다.
<details>
<summary>상세 답변</summary>
  
  네, JavaScript의 스프레드 연산자와 slice() 메서드에 대해 설명해 드리겠습니다.
  
  1. 스프레드 연산자 (Spread Operator)
      
      스프레드 연산자는 `...`로 표시되며, ES6(ES2015)에서 도입되었습니다. 이 연산자는 배열이나 객체를 "펼치는" 역할을 합니다.
      
      주요 용도:
      
      a) 배열 복사:
      
      ```jsx
      const arr1 = [1, 2, 3];
      const arr2 = [...arr1];// [1, 2, 3]
      ```
      
      b) 배열 병합:
      
      ```jsx
      const arr1 = [1, 2, 3];
      const arr2 = [4, 5, 6];
      const combined = [...arr1, ...arr2];// [1, 2, 3, 4, 5, 6]
      ```
      
      c) 함수 인자로 전달:
      
      ```jsx
      function sum(x, y, z) {
        return x + y + z;
      }
      const numbers = [1, 2, 3];
      console.log(sum(...numbers));// 6
      ```
      
      d) 객체 복사 및 병합:
      
      ```jsx
      const obj1 = { a: 1, b: 2 };
      const obj2 = { ...obj1, c: 3 };// { a: 1, b: 2, c: 3 }
      ```
      
  2. slice() 메서드
      
      slice() 메서드는 배열의 특정 부분을 새로운 배열로 반환합니다. 원본 배열은 변경되지 않습니다.
      
      구문:
      
      ```jsx
      array.slice(startIndex, endIndex)
      ```
      
      - startIndex: 시작 인덱스 (포함)
      - endIndex: 끝 인덱스 (미포함, 생략 가능)
      
      예시:
      
      a) 기본 사용:
      
      ```jsx
      const fruits = ['apple', 'banana', 'orange', 'mango'];
      console.log(fruits.slice(1, 3));// ['banana', 'orange']
      ```
      
      b) 끝까지 선택:
      
      ```jsx
      console.log(fruits.slice(2));// ['orange', 'mango']
      ```
      
      c) 마지막 요소 선택:
      
      ```jsx
      console.log(fruits.slice(-1));// ['mango']
      ```
      
      d) 배열 복사:
      
      ```jsx
      const fruitsCopy = fruits.slice();
      ```
      
  
  주요 차이점:
  
  1. 스프레드 연산자는 ES6 이상에서 사용 가능하지만, slice()는 모든 JavaScript 버전에서 사용 가능합니다.
  2. 스프레드 연산자는 배열과 객체 모두에 사용할 수 있지만, slice()는 배열에만 사용됩니다.
  3. slice()는 시작과 끝 인덱스를 지정하여 부분 배열을 만들 수 있지만, 스프레드 연산자는 전체 배열을 펼칩니다.
  
  이 두 기능에 대해 더 자세히 알고 싶은 부분이 있다면 말씀해 주세요.
</details>
<br><br>

***Q***. 둘 다 펼치는 역할을 하는 동시에 얕은 복사를 수행하는거야?

***A***. YES

<details>
<summary>상세 답변</summary>    
  네, 맞습니다. 스프레드 연산자와 slice() 메서드 모두 얕은 복사(shallow copy)를 수행합니다. 이 점에 대해 더 자세히 설명드리겠습니다.
  
  1. 얕은 복사 (Shallow Copy)
      
      얕은 복사란 객체의 최상위 수준의 속성만 복사하는 것을 의미합니다. 즉, 중첩된 객체나 배열의 경우 참조만 복사되고 실제 데이터는 공유됩니다.
      
  2. 스프레드 연산자의 얕은 복사
      
      ```jsx
      const originalArray = [1, 2, [3, 4]];
      const copiedArray = [...originalArray];
      
      console.log(copiedArray);// [1, 2, [3, 4]]
      console.log(copiedArray === originalArray);// false
      console.log(copiedArray[2] === originalArray[2]);// true
      ```
      
      이 예에서 최상위 배열은 새로운 배열로 복사되지만, 내부 배열 [3, 4]는 여전히 원본과 같은 참조를 공유합니다.
      
  3. slice()의 얕은 복사
      
      ```jsx
      const originalArray = [1, 2, [3, 4]];
      const copiedArray = originalArray.slice();
      
      console.log(copiedArray);// [1, 2, [3, 4]]
      console.log(copiedArray === originalArray);// false
      console.log(copiedArray[2] === originalArray[2]);// true
      ```
      
      slice() 메서드도 스프레드 연산자와 동일하게 얕은 복사를 수행합니다.
      
  4. 주의점
      
      얕은 복사의 특성 때문에 중첩된 객체나 배열을 수정할 때 예상치 못한 부작용이 발생할 수 있습니다:
      
      ```jsx
      const original = [{ name: 'John' }, { name: 'Jane' }];
      const copy = [...original];
      
      copy[0].name = 'Mike';
      console.log(original[0].name);// 'Mike'
      ```
      
      이 경우, 복사본을 수정했지만 원본도 함께 변경되었습니다.
      
  5. 깊은 복사 (Deep Copy)
      
      얕은 복사의 한계를 극복하기 위해 깊은 복사를 사용할 수 있습니다. 깊은 복사는 모든 중첩 수준의 데이터를 완전히 새로운 복사본으로 만듭니다.
      
      간단한 깊은 복사 방법:
      
      ```jsx
      const deepCopy = JSON.parse(JSON.stringify(original));
      ```
      
      하지만 이 방법은 함수, undefined, Symbol 등을 처리하지 못하는 한계가 있습니다.
      
  
  결론적으로, 스프레드 연산자와 slice() 메서드는 모두 얕은 복사를 수행하며, 이는 간단한 데이터 구조에서는 효과적이지만 복잡한 중첩 구조에서는 주의가 필요합니다. 깊은 복사가 필요한 경우, 별도의 방법을 사용해야 합니다.
</details>
<br><br>

***Q***. 깊은 복사는 내장 함수로는 구현되어있는게 없어? 자체적으로 재귀적 함수를 만들어야하는거야?

***A***. YES

<details>
<summary>상세 답변</summary>
  
  네, 안타깝게도 JavaScript에는 모든 상황에 대응할 수 있는 내장 깊은 복사 함수가 없습니다. 그래서 대부분의 경우 직접 구현하거나 라이브러리를 사용해야 합니다. 하지만 몇 가지 대안들이 있습니다:
  
  1. 구조화된 복제 알고리즘 (Structured Clone Algorithm)
      
      최신 브라우저와 Node.js 환경에서는 `structuredClone()` 함수를 사용할 수 있습니다:
      
      ```jsx
      const original = { nested: { array: [1, 2, 3] }, date: new Date() };
      const clone = structuredClone(original);
      ```
      
      이 방법은 대부분의 JavaScript 객체를 깊은 복사할 수 있지만, 함수나 DOM 노드는 복사할 수 없습니다.
      
      ["structuredclone" | Can I use](https://caniuse.com/?search=structuredclone)
      
      [structuredClone() | MDN](https://developer.mozilla.org/ko/docs/Web/API/structuredClone)
      
  2. JSON 메서드 사용
      
      앞서 언급한 방법입니다:
      
      ```jsx
      const deepCopy = JSON.parse(JSON.stringify(original));
      ```
      
      이 방법은 간단하지만 함수, undefined, Symbol, 순환 참조 등을 처리하지 못합니다.
      
  3. 재귀적 함수 구현
      
      복잡한 객체를 깊은 복사하기 위해 재귀 함수를 직접 구현할 수 있습니다:
      
      ```jsx
      function deepCopy(obj) {
        if (typeof obj !== 'object' || obj === null) return obj;
      
        let copy = Array.isArray(obj) ? [] : {};
      
        for (let key in obj) {
          if (obj.hasOwnProperty(key)) {
            copy[key] = deepCopy(obj[key]);
          }
        }
      
        return copy;
      }
      ```
      
      이 함수는 기본적인 깊은 복사를 수행하지만, 특수한 객체 타입(예: [Date](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date), [RegExp](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp))이나 순환 참조는 처리하지 못합니다.
      
  4. 라이브러리 사용
      
      많은 개발자들이 이 문제를 해결하기 위해 라이브러리를 사용합니다. 예를 들어, [Lodash](https://lodash.com/) 라이브러리의 `_.cloneDeep()` 함수는 매우 강력한 깊은 복사 기능을 제공합니다:
      
      ```jsx
      const _ = require('lodash');
      const deepCopy = _.cloneDeep(original);
      ```
      
  
  결론적으로, JavaScript에는 모든 상황에 완벽하게 대응하는 내장 깊은 복사 함수가 없습니다. 상황에 따라 `structuredClone()`을 사용하거나, 간단한 경우 JSON 메서드를 사용할 수 있습니다. 더 복잡한 경우에는 직접 재귀 함수를 구현하거나 신뢰할 수 있는 라이브러리를 사용하는 것이 좋습니다. 각 방법은 장단점이 있으므로, 프로젝트의 요구사항에 맞는 방법을 선택해야 합니다.
</details>
<br><br>

***Q***. 그럼 얕은 복사를 수행하는 내장함수는 뭐가 더 있어? 스프레드 연산자랑 slice() 외에

***A***. Object.assign(), Array.from(), Array.prototype.concat(), new Map()/Set() 등

<details>
<summary>상세 답변</summary>
  
  네, JavaScript에는 스프레드 연산자와 slice() 외에도 얕은 복사를 수행하는 여러 내장 함수와 메서드가 있습니다. 주요한 것들을 소개해 드리겠습니다:
  
  1. Object.assign()
      
      객체를 복사할 때 사용합니다:
      
      ```jsx
      const original = { a: 1, b: 2 };
      const copy = Object.assign({}, original);
      ```
      
  2. Array.from()
      
      배열을 복사할 때 사용할 수 있습니다:
      
      ```jsx
      const original = [1, 2, 3];
      const copy = Array.from(original);
      ```
      
  3. Array.prototype.concat()
      
      배열을 복사하거나 여러 배열을 합칠 때 사용합니다:
      
      ```jsx
      const original = [1, 2, 3];
      const copy = original.concat();
      ```
      
  4. Map 생성자
      
      Map 객체를 복사할 때 사용합니다:
      
      ```jsx
      const original = new Map([[1, 'one'], [2, 'two']]);
      const copy = new Map(original);
      ```
      
  5. Set 생성자
      
      Set 객체를 복사할 때 사용합니다:
      
      ```jsx
      const original = new Set([1, 2, 3]);
      const copy = new Set(original);
      ```
      
  6. Array.prototype.map()
      
      배열의 모든 요소에 함수를 적용하면서 복사할 때 사용할 수 있습니다:
      
      ```jsx
      const original = [1, 2, 3];
      const copy = original.map(x => x);
      ```
      
  7. Object.create()
      
      프로토타입 체인을 유지하면서 객체를 얕은 복사할 때 사용할 수 있습니다:
      
      ```jsx
      const original = { a: 1, b: 2 };
      const copy = Object.create(Object.getPrototypeOf(original), Object.getOwnPropertyDescriptors(original));
      ```
      
  
  주의사항:
  
  - 이 모든 방법들은 얕은 복사를 수행합니다. 즉, 중첩된 객체나 배열은 여전히 참조로 복사됩니다.
  - 각 방법은 특정 데이터 유형이나 상황에 더 적합할 수 있으므로, 사용 목적에 맞게 선택해야 합니다.
  - 성능 측면에서는 스프레드 연산자나 Object.assign()이 일반적으로 가장 빠르지만, 브라우저나 환경에 따라 다를 수 있습니다.
  
  이러한 방법들을 상황에 맞게 적절히 사용하면 다양한 경우의 얕은 복사를 효과적으로 수행할 수 있습니다.
</details>
<br><br>

***Q***. 객체와 배열 각각에서 성능이 빠른 순서대로 알려줘. 성능이 나빠질 수도 있는 케이스도 같이 알려주면 좋고

***A***. 객체는 스프레드 > assign() > for in, 배열은 스프레드 > slice() > Array.from() > for

성능이 나빠지는 케이스는 데이터가 많을 때

<details>
<summary>상세 답변</summary>
  
  객체와 배열의 얕은 복사 방법에 대한 성능 순위를 알려드리겠습니다. 단, 성능은 브라우저 엔진, JavaScript 버전, 데이터 크기 등에 따라 달라질 수 있으므로 일반적인 경향성을 기준으로 설명드리겠습니다.
  
  **객체 (Object)** 얕은 복사:
  
  1. 스프레드 연산자 (...)
      
      ```jsx
      const copy = { ...original };
      ```
      
  2. Object.assign()
      
      ```jsx
      const copy = Object.assign({}, original)
      ```
      
  3. 수동 복사 (for...in 루프)
      
      ```jsx
      const copy = {};
      for (let key in original) {
        if (original.hasOwnProperty(key)) {
          copy[key] = original[key];
        }
      }
      ```
      
  
  성능이 나빠질 수 있는 케이스:
  
  - 객체의 속성 수가 매우 많을 때 (수천 개 이상)
  - 객체에 getter/setter가 정의되어 있을 때 (특히 Object.assign() 사용 시)
  
  **배열 (Array)** 얕은 복사:
  
  1. 스프레드 연산자 (...)
      
      ```jsx
      const copy = [...original];
      ```
      
  2. slice()
      
      ```jsx
      const copy = original.slice();
      ```
      
  3. Array.from()
      
      ```jsx
      const copy = Array.from(original);
      ```
      
  4. 수동 복사 (for 루프)
      
      ```jsx
      const copy = [];
      for (let i = 0; i < original.length; i++) {
        copy[i] = original[i];
      }
      ```
      
  
  성능이 나빠질 수 있는 케이스:
  
  - 배열의 길이가 매우 길 때 (수만 개 이상의 요소)
  - 배열에 희소 요소(sparse elements)가 많을 때
  
  주의사항 및 추가 정보:
  
  1. 스프레드 연산자와 Object.assign()은 대부분의 경우 매우 비슷한 성능을 보입니다. 최신 JavaScript 엔진에서는 이 둘의 성능 차이가 미미합니다.
  2. 배열의 경우, 스프레드 연산자와 slice()의 성능도 대부분의 경우 매우 유사합니다.
  3. Array.from()은 일반적으로 스프레드 연산자나 slice()보다 약간 느립니다. 그러나 두 번째 인자로 매핑 함수를 제공할 수 있어 유용할 때가 있습니다.
  4. 수동 복사 방법(for 루프 등)은 작은 객체나 배열에서는 오히려 더 느릴 수 있지만, 매우 큰 데이터셋에서는 더 효율적일 수 있습니다.
  5. Object.create()는 프로토타입 체인을 유지해야 할 때 유용하지만, 일반적인 얕은 복사 목적으로는 다른 방법들보다 느립니다.
  
  성능 최적화를 위해서는 실제 애플리케이션에서 사용되는 데이터로 벤치마크를 수행하는 것이 가장 좋습니다. 또한, 대부분의 경우 이러한 복사 작업의 성능 차이는 애플리케이션 전체 성능에 큰 영향을 미치지 않으므로, 코드의 가독성과 유지보수성을 우선적으로 고려하는 것이 좋습니다.
</details>
<br><br>

***Q***. 근데 성능의 순위를 정할 수 있으면 왜 굳이 이렇게 다양한 메서드를 제공하는거야? 개발자들끼리의 코딩 스타일이 달라서 같은 기능에도 서로 다른 메서드를 사용하면 유지보수할 때 불편할 수 있잖아

***A***. 오래된 메서드가 호환을 위해 유지되고 있기도 하고 상황에 따라 최적화된 메서드가 다름
→ 팀 내에서 가이드라인을 정할 것

<details>
<summary>상세 답변</summary>
  
  좋은 질문입니다. 여러 메서드가 존재하는 이유에 대해 설명드리겠습니다:
  
  1. 역사적 이유
  JavaScript는 오랜 기간 동안 발전해왔습니다. 새로운 메서드들이 추가되었지만, 이전 메서드들도 하위 호환성을 위해 유지되고 있습니다.
  2. 특수한 사용 사례
  각 메서드는 특정 상황에서 더 유용할 수 있습니다. 예를 들어:
      - `Object.assign()`은 여러 객체를 병합할 때 유용합니다.
      - `Array.from()`은 유사 배열 객체나 이터러블을 배열로 변환할 때 사용됩니다.
  3. 표현력과 가독성
  특정 상황에서 어떤 메서드가 더 명확하고 의도를 잘 표현할 수 있습니다. 예를 들어, 배열을 복사할 때 `slice()`는 그 의도를 명확히 전달합니다.
  4. 성능 최적화
  특정 브라우저나 환경에서 어떤 메서드가 더 최적화되어 있을 수 있습니다.
  5. 기능의 확장성
  일부 메서드는 추가적인 기능을 제공합니다. 예를 들어, `Array.from()`은 매핑 함수를 받을 수 있어 복사와 동시에 변환을 수행할 수 있습니다.
  6. 개발자 선호도
  개발자들은 자신이 익숙한 방식을 선호할 수 있습니다.
  
  하지만 귀하의 우려 사항도 매우 타당합니다. 코드의 일관성과 유지보수성은 중요한 고려 사항입니다. 이를 해결하기 위한 방법들이 있습니다:
  
  1. 코딩 표준 설정
  팀이나 프로젝트에서 특정 작업에 사용할 메서드를 정의하고 문서화합니다.
  2. 린트 규칙 사용
  ESLint와 같은 도구를 사용하여 일관된 코딩 스타일을 강제할 수 있습니다.
  3. 유틸리티 함수 생성
  프로젝트 내에서 사용할 표준 복사 함수를 만들어 사용할 수 있습니다.
  4. 코드 리뷰
  일관성 있는 코드 작성을 위해 코드 리뷰 과정에서 이러한 부분을 체크할 수 있습니다.
  5. 교육과 가이드라인
  팀 내에서 선호되는 방식에 대한 교육과 가이드라인을 제공합니다.
  
  결론적으로, 다양한 메서드의 존재는 JavaScript의 유연성과 다양한 사용 사례를 반영합니다. 그러나 실제 프로젝트에서는 일관성과 유지보수성을 위해 팀이나 프로젝트 차원에서 표준을 정하고 따르는 것이 중요합니다.
</details>
</aside>
<br><br>

### ✨ 꼬리질문2 - React setState()

<aside>

***Q***. React에서 setState를 할 때 state 값에 중첩 객체가 포함되더라도 첫 번째 수준의 일반 값에서 변화가 생겼다면 `setState(prev => {...prev, a: newValue})` 이런 식으로 값을 넘겨줘도 리렌더링이 문제없이 일어나?

***A***. YES
<details>
<summary>상세 답변</summary>
  
  네, 맞습니다. React에서 setState를 사용할 때, 첫 번째 수준(top-level)의 값이 변경되면 리렌더링이 정상적으로 일어납니다. 이는 중첩된 객체가 포함되어 있더라도 마찬가지입니다.
  
  `setState(prev => ({...prev, a: newValue}))` 와 같은 방식으로 상태를 업데이트하면:
  
  1. `...prev`를 통해 이전 상태의 모든 속성을 새 객체에 복사합니다.
  2. `a: newValue`로 'a' 속성을 새 값으로 덮어씁니다.
  
  React는 이전 상태와 새 상태를 얕은 비교(shallow comparison)를 통해 비교합니다. 첫 번째 수준에서 변경이 감지되면(이 경우 'a' 속성), React는 컴포넌트를 리렌더링합니다.
  
  하지만 주의할 점이 있습니다:
  
  1. 중첩된 객체의 깊은 속성을 변경할 경우, React는 자동으로 이를 감지하지 못할 수 있습니다. 이 경우 수동으로 새 객체를 생성하여 변경을 알려야 할 수 있습니다.
  2. 성능 최적화를 위해 React.memo, useMemo, useCallback 등을 사용하는 경우, 의도치 않은 리렌더링이 발생할 수 있으므로 주의가 필요합니다.
  
  더 자세한 설명이 필요하거나 특정 사용 사례에 대해 궁금한 점이 있다면 말씀해 주세요.
</details>
<br><br>

***Q***. 그럼 중첩된 객체의 깊은 속성을 변경할 때는

```jsx
// state = {a: {x: 0, y: 1}, b: 2, c: 3} 이라는 가정
const newValue = {...state.a, x: 1};
setState(prev => ({...prev, a: newValue}));
```

이런식으로 수정하면 정상적으로 리렌더링이 발생할까?

***A***. YES

<details>
<summary>상세 답변</summary>
  
  네, 말씀하신 방식으로 중첩된 객체의 깊은 속성을 변경하면 정상적으로 리렌더링이 발생합니다.
  
  코드를 단계별로 살펴보겠습니다:
  
  1. `const newValue = {...state.a, x: 1};`
      - 이 줄에서 `state.a` 객체의 얕은 복사본을 만들고, `x` 속성을 1로 업데이트합니다.
      - 이렇게 하면 `newValue`는 `a` 객체의 새로운 참조가 됩니다.
  2. `setState(prev => ({...prev, a: newValue}));`
      - 이 줄에서는 이전 상태(`prev`)의 얕은 복사본을 만들고, `a` 속성을 새로 만든 `newValue`로 대체합니다.
      - 이는 상태의 최상위 수준에서 `a` 속성의 참조가 변경됨을 의미합니다.
  
  이 방식은 다음과 같은 이유로 정상적인 리렌더링을 유발합니다:
  
  1. 최상위 수준 변경: React는 상태 객체의 최상위 수준 속성들을 얕게 비교합니다. `a` 속성의 참조가 변경되었으므로, React는 이를 변경으로 인식합니다.
  2. 새로운 객체 참조: `newValue`는 새로운 객체 참조이므로, React는 `a` 속성이 변경되었다고 판단합니다.
  3. 불변성 유지: 이 방식은 기존 상태를 직접 수정하지 않고 새로운 객체를 생성하여 불변성을 유지합니다. 이는 React의 상태 관리 및 렌더링 최적화 메커니즘과 잘 맞습니다.
  
  이 접근 방식은 중첩된 객체의 속성을 변경할 때 안전하고 효과적인 방법입니다. 상태의 구조가 더 복잡해지면 `immer` 같은 라이브러리를 사용하여 중첩된 상태 업데이트를 더 쉽게 관리할 수도 있습니다.
  
  추가적인 질문이나 다른 시나리오에 대해 궁금한 점이 있으시면 말씀해 주세요.
</details>
<br><br>

***Q***. immer는 어떤 라이브러리야?

***A***. 간편하게 불변성을 관리할 수 있는 JS 라이브러리
<details>
<summary>상세 답변</summary>
  
  Immer는 불변성(immutability)을 쉽게 다룰 수 있게 해주는 JavaScript 라이브러리입니다. 특히 React와 같은 프레임워크에서 상태 관리를 할 때 매우 유용합니다. Immer의 주요 특징과 장점을 설명해 드리겠습니다:
  
  1. 간편한 불변성 관리:
      - Immer를 사용하면 마치 객체를 직접 수정하는 것처럼 코드를 작성할 수 있지만, 실제로는 불변성을 유지합니다.
  2. 중첩된 객체 처리 용이:
      - 복잡하고 중첩된 객체 구조에서도 쉽게 상태를 업데이트할 수 있습니다.
  3. 가독성 향상:
      - 복잡한 스프레드 연산자 사용을 줄여 코드의 가독성을 높입니다.
  4. 성능 최적화:
      - 내부적으로 구조적 공유(structural sharing)를 사용하여 메모리 사용을 최적화합니다.
  5. 타입 안정성:
      - TypeScript와 잘 통합되어 타입 안정성을 제공합니다.
  
  간단한 사용 예시를 보여드리겠습니다:
  
  ```jsx
  import produce from 'immer';
  
  const baseState = {
    users: [
      { id: 1, name: "John" },
      { id: 2, name: "Mary" }
    ]
  };
  
  const nextState = produce(baseState, draft => {
  // 'draft'를 직접 수정하는 것처럼 보이지만, 실제로는 새로운 불변 상태를 생성합니다.
    draft.users[1].name = "Mary Jane";
    draft.users.push({ id: 3, name: "Tom" });
  });
  ```
  
  이 예시에서 `produce` 함수는 기존 상태(`baseState`)를 받아 새로운 불변 상태를 생성합니다. 내부 콜백에서는 마치 객체를 직접 수정하는 것처럼 코드를 작성할 수 있지만, Immer가 이를 불변적인 방식으로 처리합니다.
  
  React에서 Immer를 사용하면 복잡한 상태 업데이트를 더 간단하고 직관적으로 할 수 있습니다. 특히 중첩된 객체나 배열을 다룰 때 매우 유용합니다.
  
  Immer의 사용이 적절한 상황이나 구체적인 React 예제가 필요하시다면 더 자세히 설명해 드릴 수 있습니다.
</details>
<br><br>

***Q***. `state = {a: {x: 0, y: 1}, b: 2, c: 3}` 일 때 `setState(prev => ({...prev, b: newValue}))`를 수행한다고해도 state에 대해서는 `state.a.x = newValue` 이런식으로 값을 직접 바꾸지는 않으니까 중첩된 객체가 얕은복사가 되었어도 크게 문제될 부분은 없지?

***A***. YES
<details>
<summary>상세 답변</summary>
  
  네, 정확히 말씀하셨습니다. 당신의 예시에서 `setState(prev => ({...prev, b: newValue}))`를 수행할 때, `state.a.x`와 같은 중첩된 객체의 속성을 직접 수정하지 않습니다. 이 접근 방식은 React의 불변성 원칙을 잘 지키며, 대부분의 경우 안전합니다. 이에 대해 더 자세히 설명드리겠습니다:
  
  1. 최상위 레벨 불변성:
      - `{...prev, b: newValue}`는 최상위 레벨에서 새로운 객체를 생성합니다.
      - `a`와 `c` 속성은 이전 상태의 참조를 그대로 유지합니다.
      - `b` 속성만 새로운 값으로 업데이트됩니다.
  2. 중첩 객체의 안전성:
      - `a` 객체는 얕은 복사로 인해 이전 상태의 참조를 그대로 유지합니다.
      - `state.a.x`나 `state.a.y`를 직접 수정하지 않으므로, `a` 객체의 내부 구조는 변경되지 않습니다.
  3. React의 렌더링 메커니즘:
      - React는 최상위 레벨에서 상태 변화를 감지하고 리렌더링을 트리거합니다.
      - `b`의 값이 변경되었으므로, React는 이를 새로운 상태로 인식하고 적절히 처리합니다.
  4. 성능 고려사항:
      - 변경되지 않은 `a`와 `c` 속성은 이전 참조를 유지하므로, 이들을 props로 받는 자식 컴포넌트들은 불필요한 리렌더링을 피할 수 있습니다 (React.memo 등을 사용할 경우).
  
  주의할 점:
  
  1. 의도치 않은 변경:
      - `state.a.x = newValue`와 같은 직접적인 변경을 하지 않도록 주의해야 합니다. 이는 React의 불변성 원칙을 위반하며 예기치 않은 동작을 초래할 수 있습니다.
  2. 깊은 중첩 객체:
      - 만약 `a` 객체 내부의 속성을 변경하고 싶다면, 별도의 처리가 필요합니다. 예를 들어:
          
          ```jsx
          setState(prev => ({
            ...prev,
            a: {...prev.a, x: newXValue}
          }));
          ```
          
  
  결론적으로, `setState(prev => ({...prev, b: newValue}))`와 같은 방식은 안전하고 효과적입니다. 중첩된 객체 `a`의 내부 속성을 직접 수정하지 않으므로 불변성이 유지되며, React의 상태 관리 및 렌더링 메커니즘과 잘 동작합니다. 이 방식은 대부분의 상황에서 권장되는 좋은 실천 방법입니다.
</details>
<br><br>

***Q***. 직전 질문의 상황에서 memo를 사용할 때 고려할 사항이 있을까?

***A***. 부모 컴포넌트에서 매번 새로운 객체를 생성하여 전달한다면 얕은 비교를 수행하는 React.memo에서 제대로된 memo 효과를 얻지 못할 수 있다.
<details>
<summary>상세 답변</summary>
  
  네, memo를 사용할 때 고려해야 할 중요한 사항들이 있습니다. 주어진 상황(`state = {a: {x: 0, y: 1}, b: 2, c: 3}`)에서 memo를 사용할 때 고려해야 할 점들을 설명드리겠습니다:
  
  1. 얕은 비교의 한계:
      - React.memo는 기본적으로 props의 얕은 비교를 수행합니다.
      - `b`나 `c`와 같은 원시 값을 props로 전달할 때는 문제가 없지만, `a`와 같은 객체를 전달할 때는 주의가 필요합니다.
  2. 객체 props의 안정성:
      - `a` 객체를 props로 전달하는 경우, 부모 컴포넌트가 리렌더링될 때마다 `a`의 참조가 변경되지 않아야 memo가 효과적으로 작동합니다.
      - 만약 부모 컴포넌트에서 매번 `{...state.a}`와 같이 새로운 객체를 생성하여 전달한다면, memo의 이점을 얻기 어려울 수 있습니다.
  3. 중첩 객체 속성 변경:
      - `a.x`나 `a.y`의 값만 변경되는 경우, `a` 객체의 참조는 변경되지 않습니다. 이 경우 memo를 사용하는 자식 컴포넌트는 변경을 감지하지 못할 수 있습니다.
  4. 콜백 함수 props:
      - 객체 속성을 변경하는 콜백 함수를 props로 전달할 때, 이 함수의 참조가 변경되지 않도록 주의해야 합니다. useCallback을 사용하여 함수 참조를 안정화할 수 있습니다.
  5. 커스텀 비교 함수:
      - 복잡한 객체 구조에서는 memo의 두 번째 인자로 커스텀 비교 함수를 제공하여 더 정확한 비교를 수행할 수 있습니다.
  
  이러한 상황을 고려한 예시 코드를 보여드리겠습니다:
  
  ```jsx
  import React, { useState, useCallback, memo } from 'react';
  
  const ParentComponent = () => {
    const [state, setState] = useState({a: {x: 0, y: 1}, b: 2, c: 3});
  
  // a.x를 변경하는 안정적인 콜백 함수
    const updateX = useCallback((newX) => {
      setState(prev => ({
        ...prev,
        a: {...prev.a, x: newX}
      }));
    }, []);
  
    return (
      <div>
        <ChildComponent a={state.a} b={state.b} updateX={updateX} />
      </div>
    );
  };
  
  const ChildComponent = memo(({ a, b, updateX }) => {
    console.log('ChildComponent rendered');
    return (
      <div>
        <p>a.x: {a.x}, a.y: {a.y}, b: {b}</p>
        <button onClick={() => updateX(a.x + 1)}>Increment X</button>
      </div>
    );
  }, (prevProps, nextProps) => {
  // 커스텀 비교 함수: a의 내부 값들과 b를 개별적으로 비교
    return prevProps.a.x === nextProps.a.x &&
            prevProps.a.y === nextProps.a.y &&
            prevProps.b === nextProps.b;
  });
  
  export default ParentComponent;
  ```
  
  이 예시에서:
  
  1. `useCallback`을 사용하여 `updateX` 함수의 참조 안정성을 보장합니다.
  2. `ChildComponent`에 memo를 적용하고, 커스텀 비교 함수를 제공하여 `a` 객체의 내부 값들을 개별적으로 비교합니다.
  3. `ParentComponent`에서 `state.a`를 직접 전달하여 불필요한 객체 생성을 피합니다.
  
  이러한 접근 방식을 통해 memo를 효과적으로 사용하면서도, 중첩된 객체 구조에서 발생할 수 있는 문제들을 최소화할 수 있습니다. 하지만 이런 최적화가 항상 필요한 것은 아니며, 애플리케이션의 복잡성과 성능 요구사항에 따라 적절히 적용해야 합니다.
</details>
</aside>
<br><br>

### ✨ 꼬리질문..? 3 - undefined, null

<aside>

***Q***. JS에서 빈 값을 의미할 때 의도적으로 undefined나 null을 할당하는 경우가 있잖아 undefined 대신 null을 할당하고 예외처리를 할 때 `item !== null && item !== undefined`로 조건을 걸어주는게 가장 좋은 방법이야?

***A***. 장황하기 때문에 그보다는 상황에 따라 `!=` 이나 `??`, 옵셔널 체이닝 등을 사용하는게 좋다
<details>
<summary>상세 답변</summary>
  
  JavaScript에서 빈 값을 표현할 때 `undefined`와 `null`의 사용에 대해 좋은 질문을 해주셨습니다. 이에 대한 최선의 접근 방식은 상황에 따라 다를 수 있지만, 일반적인 권장 사항과 대안을 설명해 드리겠습니다.
  
  1. `null` vs `undefined`:
      - `undefined`는 변수가 선언되었지만 값이 할당되지 않았을 때 자동으로 할당됩니다.
      - `null`은 의도적으로 '값이 없음'을 나타내기 위해 할당하는 값입니다.
  2. 예외 처리:
  `item !== null && item !== undefined`와 같은 조건은 작동하지만, 더 간결한 방법이 있습니다:
  
  이 방법은 `!=`의 타입 강제 변환(type coercion)을 이용해 `null`과 `undefined` 모두를 체크합니다.
      
      ```jsx
      if (item != null) {
        // item이 null도 아니고 undefined도 아닐 때 실행
      }
      ```
      
  3. 더 현대적인 접근 방식:
  ES6 이후로는 nullish 병합 연산자(`??`)와 옵셔널 체이닝(`?.`)을 사용할 수 있습니다:
      
      ```jsx
      const value = item ?? defaultValue;// item이 null이나 undefined면 defaultValue 사용
      const nestedValue = object?.property?.nestedProperty;// 안전하게 중첩 속성에 접근
      ```
      
  4. 일관성:
  프로젝트 내에서 `null`과 `undefined` 사용에 대한 일관된 규칙을 정하는 것이 중요합니다. 예를 들어, "존재하지 않는 값"은 항상 `null`을 사용하고, `undefined`는 초기화되지 않은 변수에만 사용하는 식으로 규칙을 정할 수 있습니다.
  
  결론적으로, `item !== null && item !== undefined`는 작동하지만 약간 장황할 수 있습니다. 상황에 따라 `item != null`이나 현대적인 연산자(`??`, `?.`)를 사용하는 것이 더 간결하고 가독성이 좋을 수 있습니다. 프로젝트의 요구사항과 팀의 코딩 스타일에 따라 가장 적합한 방식을 선택하시면 됩니다.
  
  이 주제에 대해 더 자세히 알고 싶으신 부분이 있다면 말씀해 주세요.
</details>
<br><br>

***Q***. undefined랑 null 중에 빈 객체를 의미할 때 선호하는 할당 방식이 개발자마다 달랐던 것 같은데 내가 지금 읽고있는 책에서는 undefined보다는 null을 사용하는게 더 적합하다고해. 선호하는 방식이나 팀 컨벤션대로 해도 되는걸까 아니면 책대로 null을 사용해야하는걸까? null만 사용해야한다면 구체적인 이유도 알려줘

***A***. null을 사용하는게 절대적인 규칙은 아니므로 팀 컨벤션이나 코드의 일관성을 지키는 것이 좋다.
<details>
<summary>상세 답변</summary>
  
  이는 매우 좋은 질문입니다. `undefined`와 `null` 사용에 대한 선호도는 개발자와 팀마다 다를 수 있으며, 이는 JavaScript 커뮤니티에서 오랫동안 논의되어 온 주제입니다. 책에서 `null`을 선호한다고 언급한 것은 일반적인 관행 중 하나를 반영한 것일 수 있습니다. 하지만 절대적인 규칙은 아닙니다.
  
  여기 몇 가지 고려해볼 점들이 있습니다:
  
  1. 팀 컨벤션의 중요성:
      - 일관성은 코드 가독성과 유지보수성에 매우 중요합니다.
      - 팀이나 프로젝트에서 이미 확립된 컨벤션이 있다면, 그것을 따르는 것이 대체로 좋습니다.
  2. `null` 사용의 장점:
      - `null`은 의도적으로 '값이 없음'을 나타내기 위해 사용됩니다.
      - 객체나 참조 타입의 부재를 나타내는 데 더 적합할 수 있습니다.
      - `typeof null`은 `'object'`를 반환하므로, 객체 타입과의 일관성을 유지할 수 있습니다.
  3. `undefined` 사용의 장점:
      - JavaScript에서 자동으로 할당되는 기본값이므로, 언어의 자연스러운 동작과 일치합니다.
      - 함수 파라미터가 전달되지 않았을 때의 기본값입니다.
  4. 상황에 따른 선택:
      - 때로는 상황에 따라 `null`과 `undefined`를 구분해서 사용하는 것이 유용할 수 있습니다.
      - 예를 들어, `null`은 '의도적으로 값이 없음'을, `undefined`는 '아직 값이 할당되지 않음'을 나타내는 데 사용할 수 있습니다.
  5. 일관성과 명확성:
      - 어떤 방식을 선택하든, 프로젝트 전체에서 일관되게 사용하는 것이 중요합니다.
      - 선택한 방식에 대한 명확한 문서화와 팀원 간의 합의가 필요합니다.
  
  결론적으로, 책에서 `null`을 권장한다고 해서 반드시 그것만을 사용해야 하는 것은 아닙니다. 중요한 것은 팀이나 프로젝트의 맥락, 그리고 일관성입니다. 만약 팀에서 이미 `undefined`를 사용하고 있고 그것이 잘 작동한다면, 그대로 유지하는 것도 좋은 선택일 수 있습니다.
  
  다만, 새로운 프로젝트를 시작하거나 코딩 스타일을 재정립할 때는 `null` 사용을 고려해볼 만합니다. `null`이 '의도적인 부재'를 더 명확히 나타낼 수 있고, 일부 개발자들이 이를 선호하는 이유입니다.
  
  중요한 것은 선택한 방식을 일관되게 적용하고, 팀 내에서 명확히 소통하는 것입니다. 어떤 방식을 선택하든, 그 이유를 팀원들과 공유하고 문서화하는 것이 도움이 될 것입니다.
</details>
<br><br>

***Q***. React에서 useState를 쓸 때 초기값에 null을 사용했는데 여기에 undefined를 할당하는 케이스도 많을까?

***A***. 없진 않다. 중요한건 팀 내 소통과 일관성
<details>
<summary>상세 답변</summary>
  
  React에서 `useState`를 사용할 때 초기값으로 `null`과 `undefined`를 사용하는 것에 대해 살펴보겠습니다.
  
  일반적으로 `null`을 사용하는 경우가 더 흔하지만, `undefined`를 사용하는 경우도 있습니다. 각각의 사용 사례와 장단점을 살펴보겠습니다:
  
  1. `null` 사용:
      
      ```jsx
      const [user, setUser] = useState(null);
      ```
      
      - 장점:
          - '아직 데이터가 없음'을 명시적으로 나타냅니다.
          - 객체나 배열의 부재를 나타내는 데 자주 사용됩니다.
      - 단점:
          - `typeof null`이 `'object'`를 반환하므로 타입 체크 시 주의가 필요합니다.
  2. `undefined` 사용:
      
      ```jsx
      const [user, setUser] = useState(undefined);
      ```
      
      - 장점:
          - JavaScript의 기본 동작과 일치합니다 (선언만 되고 할당되지 않은 변수의 기본값).
          - 옵셔널 체이닝(`?.`)과 잘 동작합니다.
      - 단점:
          - 의도적으로 '값이 없음'을 나타내는 것인지, 단순히 초기화되지 않은 것인지 구분하기 어려울 수 있습니다.
  
  실제로 `undefined`를 사용하는 케이스는 `null`보다는 적지만, 다음과 같은 상황에서 볼 수 있습니다:
  
  1. 옵셔널 프롭스를 다룰 때:
      
      ```jsx
      function Component({ optionalProp }) {
        const [value, setValue] = useState(optionalProp);
        // optionalProp이 전달되지 않으면 value는 자동으로 undefined가 됩니다.
      }
      ```
      
  2. 비동기 데이터 로딩 시 초기 상태를 나타낼 때:
      
      ```jsx
      const [data, setData] = useState(undefined);
      // undefined는 '아직 데이터를 가져오지 않음'을 의미할 수 있습니다.
      ```
      
  3. 타입스크립트와 함께 사용할 때 유니온 타입을 명시적으로 나타내기 위해:
      
      ```tsx
      const [user, setUser] = useState<User | undefined>(undefined);
      ```
      
  
  결론적으로, `null`을 사용하는 경우가 더 일반적이지만, `undefined`를 사용하는 경우도 있습니다. 선택은 주로 팀의 컨벤션, 프로젝트의 요구사항, 그리고 개발자의 개인적인 선호도에 따라 달라집니다.
  
  중요한 것은 선택한 접근 방식을 일관되게 사용하고, 팀 내에서 그 의미를 명확히 소통하는 것입니다. 또한, 타입스크립트를 사용한다면 타입 안정성을 위해 명시적인 타입 선언을 고려하는 것이 좋습니다.
</details>
<br><br>

***Q***. 의도적으로 undefined를 할당할 때의 장점은 예외 조건 처리하기가 조금 더 편하다는 장점이 있을까? null은 빈 데이터라는 의미를 명시적으로 구분시킬 수 있는 장점이 있는거고?

***A***. YES
<details>
<summary>상세 답변</summary>
  
  네, 정확히 지적해주셨습니다. `undefined`와 `null`의 사용에 대한 중요한 차이점을 잘 이해하고 계십니다. 각각의 장점을 좀 더 자세히 살펴보겠습니다:
  
  1. `undefined` 사용의 장점:
  
  예를 들어:
      - 예외 조건 처리의 편의성:
          - JavaScript에서 많은 연산자와 메서드들이 `undefined`를 자연스럽게 처리합니다.
          - 옵셔널 체이닝(`?.`)과 널리시 병합 연산자(`??`)가 `undefined`와 잘 작동합니다.
      
      ```jsx
      const user = undefined;
      console.log(user?.name);// 안전하게 undefined 반환
      const displayName = user?.name ?? "Guest";// "Guest" 할당
      ```
      
      - 함수 파라미터와의 일관성:
          - 함수에 인자를 전달하지 않으면 자동으로 `undefined`가 됩니다.
      
      ```jsx
      function greet(name) {
        console.log(name === undefined ? "Hello, guest!" : `Hello, ${name}!`);
      }
      greet();// "Hello, guest!" 출력
      ```
      
  2. `null` 사용의 장점:
      - 의도적인 '비어있음'의 명시:
          - `null`은 개발자가 명시적으로 '값이 없음'을 나타내기 위해 할당한 것임을 더 명확히 표현합니다.
      - 객체나 참조 타입의 부재를 나타내는 데 더 적합:
          - `typeof null`이 `'object'`를 반환하므로, 객체 타입과의 일관성을 유지할 수 있습니다.
      
      ```jsx
      const user = null;
      if (user === null) {
        console.log("사용자 정보가 없습니다.");
      }
      ```
      
      - 데이터베이스나 API와의 일관성:
          - 많은 백엔드 시스템에서 '값 없음'을 `null`로 표현하므로, 프론트엔드에서도 `null`을 사용하면 일관성을 유지할 수 있습니다.
  
  요약하자면:
  
  - `undefined`는 변수가 선언되었지만 값이 할당되지 않았거나, 객체의 속성이 존재하지 않을 때 자동으로 할당되는 값입니다. 이는 JavaScript의 기본 동작과 일치하며, 특히 옵셔널한 값을 다룰 때 유용합니다.
  - `null`은 개발자가 의도적으로 '값이 없음'을 나타내기 위해 사용하는 값입니다. 이는 더 명시적이며, 특히 객체나 복잡한 데이터 구조에서 '의도적인 부재'를 나타내는 데 유용합니다.
  
  실제 개발에서는 이 두 가지를 상황에 따라 적절히 사용하는 것이 좋습니다. 팀 내에서 일관된 규칙을 정하고, 그 의미를 명확히 소통하는 것이 중요합니다. 또한, 타입스크립트를 사용한다면 이러한 차이를 더욱 명확히 표현하고 관리할 수 있습니다.
</details>
<br><br>

***Q***. 객체에 대해 `!myObj` 라는 조건을 사용한다면 undefined만 체크할 수 있을까?

***A***. null, NAN, 빈 문자열도 가능하다.
<details>
<summary>상세 답변</summary>
  
  좋은 질문입니다. `!myObj` 조건은 실제로 `undefined`만 체크하는 것이 아니라, JavaScript에서 "falsy"로 간주되는 여러 값들을 체크합니다. 이에 대해 자세히 설명드리겠습니다.
  
  JavaScript에서 `!` 연산자는 값을 불리언으로 변환한 후 그 결과를 뒤집습니다. 따라서 `!myObj`는 `myObj`가 "falsy" 값일 때 `true`를 반환합니다.
  
  JavaScript에서 "falsy"로 간주되는 값들은 다음과 같습니다:
  
  1. `false`
  2. `0` (숫자 0)
  3. `''` 또는 `""` (빈 문자열)
  4. `null`
  5. `undefined`
  6. `NaN`
  
  따라서 `!myObj`는 `myObj`가 위의 값들 중 하나일 때 `true`를 반환합니다. 이는 `undefined`뿐만 아니라 `null`도 포함됩니다.
  
  예를 들어:
  
  ```jsx
  let obj1 = undefined;
  let obj2 = null;
  let obj3 = {};
  let obj4 = 0;
  let obj5 = '';
  
  console.log(!obj1);// true
  console.log(!obj2);// true
  console.log(!obj3);// false (빈 객체는 "truthy"입니다)
  console.log(!obj4);// true
  console.log(!obj5);// true
  ```
  
  만약 정확히 `undefined`만을 체크하고 싶다면, 다음과 같은 방법을 사용할 수 있습니다:
  
  1. 엄격한 동등 비교 연산자 사용:
      
      ```jsx
      if (myObj === undefined) {
        // myObj가 정확히 undefined일 때만 실행
      }
      ```
      
  2. `typeof` 연산자 사용:
      
      ```jsx
      if (typeof myObj === 'undefined') {
        // myObj가 정확히 undefined일 때만 실행
      }
      ```
      
  3. `void 0`과의 비교 (좀 더 고급 기법):
      
      ```jsx
      javascript
      Copy
      if (myObj === void 0) {
      // myObj가 정확히 undefined일 때만 실행
      }
      ```
      
  
  결론적으로, `!myObj`는 `undefined`를 포함한 여러 "falsy" 값들을 체크합니다. 정확히 `undefined`만을 체크하고 싶다면 위에서 언급한 방법들 중 하나를 사용하는 것이 좋습니다. 특히 `null`과 `undefined`를 구분해야 하는 상황에서는 이러한 정확한 체크가 중요할 수 있습니다.
</details>
<br><br>

***Q***. null과 undefined를 구분해야하는 상황 예시 좀 알려줘

***A**.* API 응답 처리, 함수 default param, 폼 입력값, 캐시, 상태 관리 시스템, DB 쿼리 결과처리
<details>
<summary>상세 답변</summary>
  
  `null`과 `undefined`를 구분해야 하는 상황은 실제 개발 과정에서 꽤 자주 발생합니다. 이들을 구분해야 하는 몇 가지 중요한 상황 예시를 들어보겠습니다:
  
  1. API 응답 처리:
  API가 특정 필드에 대해 `null`(데이터 없음)과 `undefined`(필드 자체가 없음)를 구분하여 반환할 때:
      
      ```jsx
      function processUser(user) {
        if (user.age === null) {
          console.log("사용자의 나이 정보가 없습니다.");
        } else if (user.age === undefined) {
          console.log("나이 필드가 API 응답에 포함되지 않았습니다.");
        } else {
          console.log(`사용자의 나이: ${user.age}`);
        }
      }
      ```
      
  2. 함수 파라미터 기본값 설정:
  `undefined`는 파라미터가 전달되지 않았을 때의 기본값이지만, `null`은 의도적으로 '값 없음'을 전달한 경우입니다:
      
      ```jsx
      function greet(name = "Guest") {
        console.log(`Hello, ${name}!`);
      }
      
      greet(); // "Hello, Guest!" (name은 undefined)
      greet(null); // "Hello, null!" (null이 명시적으로 전달됨)
      ```
      
  3. 폼 입력 값 처리:
  사용자가 입력을 하지 않은 경우(`undefined`)와 명시적으로 값을 지운 경우(`null`)를 구분할 때:
      
      ```jsx
      function processFormField(value) {
        if (value === undefined) {
          return "필드가 터치되지 않았습니다.";
        } else if (value === null) {
          return "사용자가 값을 지웠습니다.";
        } else {
          return `입력된 값: ${value}`;
        }
      }
      ```
      
  4. 캐시 시스템:
  캐시에서 항목이 없는 경우(`undefined`)와 항목이 명시적으로 비어있음을 나타내는 경우(`null`)를 구분:
      
      ```jsx
      function getFromCache(key) {
        const value = cache.get(key);
        if (value === undefined) {
          console.log("캐시에 해당 키가 없습니다. API에서 데이터를 가져옵니다.");
          return fetchFromAPI(key);
        } else if (value === null) {
          console.log("캐시에 해당 키에 대한 '값 없음'이 저장되어 있습니다.");
          return null;
        } else {
          return value;
        }
      }
      ```
      
  5. 상태 관리 시스템 (예: Redux):
  초기 상태(`undefined`)와 데이터 로딩 실패(`null`)를 구분할 때:
      
      ```jsx
      function UserProfile({ userData }) {
        if (userData === undefined) {
          return <LoadingSpinner />;
        } else if (userData === null) {
          return <ErrorMessage>사용자 데이터를 불러오는데 실패했습니다.</ErrorMessage>;
        } else {
          return <ProfileView data={userData} />;
        }
      }
      ```
      
  6. 데이터베이스 쿼리 결과 처리:
  필드가 존재하지 않는 경우(`undefined`)와 필드가 `NULL`로 설정된 경우(`null`)를 구분:
      
      ```jsx
      function processQueryResult(result) {
        if (result.lastLoginDate === undefined) {
          console.log("lastLoginDate 필드가 쿼리 결과에 없습니다.");
        } else if (result.lastLoginDate === null) {
          console.log("사용자가 아직 로그인한 적이 없습니다.");
        } else {
          console.log(`마지막 로그인: ${result.lastLoginDate}`);
        }
      }
      ```
      
  
  이러한 예시들은 `null`과 `undefined`를 구분하는 것이 코드의 의도를 더 명확하게 표현하고, 다양한 상황을 더 정확하게 처리할 수 있게 해준다는 것을 보여줍니다. 이를 통해 더 견고하고 의미 있는 코드를 작성할 수 있습니다.
</details>
</aside>
