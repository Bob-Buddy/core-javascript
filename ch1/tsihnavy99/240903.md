## ✨ 꼬리질문1 - Symbol

#### [Symbol](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Symbol)

→ 객체의 고유한 프로퍼티 키를 설정해 프로퍼티 키의 충돌을 방지하기 위해 사용

→ 변경 불가능한 원시값

→ Symbol(description) 으로 생성(new 사용 불가)

→ 매번 새로운 심볼 생성

```jsx
const mySymbol1 = Symbol();
const mySymbol2 = Symbol();

// 여기서 mySymbol1 !== mySymbol2
```
<aside>
<br>

***Q***. Symbol은 하나의 데이터를 만드는 것이므로 단순 String 값을 키로 사용하는 것보다(`myObj["myKey"]`) 저장된 값을 찾기 위한 과정을 한 번 더 거치고 저장을 위해 메모리도 추가로 사용하는데 성능 상 문제될 점은 없나?

***A***. 일반적인 사용에서는 이로 인해 성능 저하나 추가적인 메모리 접근 비용이 발생하지 않는다.
<details>
<summary>상세 답변</summary>
  
  `Symbol`은 메타데이터나 객체의 키로서만 활용되며, 실제 데이터가 아닌 식별자 역할을 하기 때문에 대규모 메모리 사용을 유발하지 않으며 일반적인 사용에서는 이로 인해 성능 저하나 추가적인 메모리 접근 비용이 발생하지 않습니다.
  
  ES6에서 도입된 `Symbol` 타입은 고유하고 변경 불가능한 데이터 타입으로, 주로 객체의 프로퍼티 키로 사용됩니다. `Symbol`을 키로 사용하는 이유는 주어진 키가 다른 어떤 키와도 중복되지 않음을 보장하기 위해서입니다.
  
  #### 메모리 사용에 관한 사항
  
  1. **메모리 공간**:
      - `Symbol` 자체는 원시 타입이며, 그 값은 고유합니다. 그래서 `Symbol`을 생성할 때 고유한 식별자가 만들어집니다. 이 과정에서 메모리를 사용하지만, 그 사용량은 매우 작습니다. `Symbol`은 메타데이터나 객체의 키로서만 활용되며, 실제 데이터가 아닌 식별자 역할을 하기 때문에 대규모 메모리 사용을 유발하지 않습니다.
      - `Symbol`을 객체의 키로 사용할 때도 마찬가지로, 일반적인 문자열 키와 유사한 방식으로 메모리에 저장됩니다. `Symbol` 키는 고유하기 때문에 충돌을 피할 수 있고, 객체의 프로퍼티를 안전하게 보호할 수 있습니다.
  2. **메모리 접근**:
      - `Symbol` 키를 사용한 객체 프로퍼티에 접근하는 과정은 다른 키를 사용하는 것과 기본적으로 동일합니다. 다만, `Symbol` 키는 고유한 식별자로 구현되어 있어, 엔진이 해당 키를 처리하는 방식이 다를 수 있습니다. 그러나 일반적인 사용에서는 이로 인해 성능 저하나 추가적인 메모리 접근 비용이 발생하지 않습니다.
  
  #### 결론:
  
  - `Symbol` 키를 사용하는 것이 메모리 공간을 특별히 더 많이 사용하거나 메모리 접근 과정에서 큰 성능 오버헤드를 유발하지는 않습니다. `Symbol`은 고유성을 보장하고 충돌을 방지하기 위한 도구로, 이 점에서 유용합니다.
  
  이러한 특성으로 인해 `Symbol`을 사용하는 것이 객체의 안전성을 높이는 데 도움이 되며, 메모리 사용과 성능 측면에서도 큰 부담이 되지 않습니다.
</details>
<br>
<br>

***Q***. 코드 작성자의 입장에서는 고유한 key값을 위해 코드를 더 많이 작성해야 하는 부분도 있을 것 같은데 작성 과정이나 유지보수 측면에서는 불편한 게 없나?

***A***. 코드의 가독성, 유지보수성, 디버깅 용이성 측면에서 볼 때 단점도 존재하기 때문에 Symbol은 남용하기보단 필요한 경우에만 사용하는 게 좋다.
<details>
<summary>상세 답변</summary>
  
  `Symbol`을 키로 사용하는 것은 고유한 식별자를 보장하지만, 코드 작성과 유지보수 측면에서 몇 가지 고려해야 할 사항이 있습니다.
  
  - **1. 코드 가독성**
      - **장점**: 키 충돌을 완벽히 피할 수 있어 라이브러리나 모듈 간에 충돌 없이 안전하게 객체 프로퍼티를 정의할 수 있다. → 대규모 프로젝트나 여러 모듈이 동시에 작동하는 환경에서 유용
      - **단점**: 해당 키가 어떤 의미를 갖는지 즉시 파악하기 어려울 수 있다. 디버깅 시에 직관적인 이름이나 문자열로 확인할 수 없어 가독성을 떨어뜨릴 수 있다.
  - **2. 유지보수**
      - **장점**: 코드의 특정 부분에서만 사용될 수 있는 고유한 키를 생성하기 때문에 의도하지 않은 프로퍼티 오버라이드를 방지할 수 있다. → 장기적인 유지보수 쉬워짐
      - **단점**: `Symbol` 키는 기본적으로 `Object.keys()`나 `for...in` 루프에 나타나지 않아 전체 객체의 구조를 파악하기가 어려울 수 있고 `Symbol`이 어디서 생성되고 어떻게 사용되는지 명확히 문서화하지 않으면 나중에 유지보수를 하거나 다른 사람이 코드를 읽을 때 혼란을 초래할 수 있다.
  - **3. 코드 작성**
      - **장점**: 고유한 키를 쉽게 생성할 수 있어, 별도의 네이밍 충돌을 신경 쓸 필요가 없다.
      - **단점**: 코드 작성 시, 모든 고유 키에 대해 `Symbol`을 생성하고 관리하는 과정이 추가된다. → 많은 수의 고유 키가 필요한 경우 번거로울 수 있으며, `Symbol`이 어디서 생성되고 어떻게 전달되는지 관리 필요
  - **4. 디버깅**
      - **단점**: 디버깅 과정에서 `Symbol`을 사용한 키는 직접적으로 문자열처럼 확인하기 어렵다.
          
          ex) `Symbol('description')`으로 생성된 `Symbol`은 `Symbol(description)`으로 출력. 내부적으로는 고유한 식별자이기 때문에 동일한 `Symbol`이 아님 → 디버깅 시 혼란을 야기할 수 있음
          
  
  **결론**
  
  - **가독성**: `Symbol` 사용 시 키의 의미를 명확히 해주기 위해 변수나 상수로 정의하는 것이 좋다.
  - **유지보수**: `Symbol` 사용을 문서화하고, 적절한 이름을 부여해 의미를 부여하는 것이 중요하다.
  - **디버깅**: `Symbol` 사용 시 디버깅 도구나 로깅을 통해 추가적인 정보를 제공하는 것이 좋다.
  
  `Symbol`은 강력하고 유용한 도구이지만, 코드의 가독성, 유지보수성, 그리고 디버깅의 용이성 측면에서 남용하지 않고 필요한 경우에만 사용하는 것이 좋습니다.
</details>
<br>
<br>

***Q***. Symbol이 코드를 숨길 수 있다는 장점이 있지만 개발자가 다른 곳에서 해당 값에 접근할 때에는 또다른 메서드를 사용해야한다거나 하는 불편함이 있을 수도 있겠네?

***A***. YES
<details>
<summary>상세 답변</summary>
  
  `Symbol`을 사용하면 코드의 특정 부분에서 프로퍼티를 "숨길" 수 있지만, 이로 인해 다른 곳에서 해당 프로퍼티에 접근할 때 추가적인 불편함이 발생할 수 있습니다. 이러한 특성은 장점이 될 수도 있지만, 동시에 불편함을 초래할 수도 있습니다.
  
  - **1. 코드 숨김의 장점**
      - `Symbol`을 키로 사용하는 경우, 해당 키는 일반적인 방법으로 접근하거나 열거할 수 없다.
          
          ex) `Object.keys()`나 `for...in` 루프에서는 `Symbol` 키가 열거되지 않음
          
      - 모듈이나 라이브러리에서 내부적으로 사용하는 프로퍼티를 외부에서 실수로 변경하지 못하게 하는 보안 장치로 활용될 수 있다. → 특정 기능을 외부에 노출하지 않으면서도 객체에 데이터를 저장할 수 있는 방법 제공
  - **2. 접근의 불편함**
      - **직접 접근**: `Symbol`로 정의된 프로퍼티에 접근하려면, 해당 `Symbol`을 직접 알고 있어야 한다.
          - 동일한 `Symbol`을 여러 곳에서 사용하려면 그 `Symbol`이 정의된 곳에서 가져와야 한다. → 코드의 종속성이 증가할 수 있음
          - `Symbol`이 외부에 공개되지 않았다면 해당 프로퍼티에 접근하기 어렵다.
      - **메서드 활용**: `Symbol` 키를 이용한 프로퍼티에 접근하기 위해서는 `Object.getOwnPropertySymbols()` 메서드를 사용해야 한다.
          
          → 객체의 모든 `Symbol` 키를 반환하는 메서드, 기본적으로 `Object.keys()`나 `for...in` 루프에서 잡히지 않는 `Symbol` 프로퍼티 탐색 가능 (일반적인 키 접근보다 번거로움)
          
          ```jsx
          const sym1 = Symbol('key1');
          const obj = {
            [sym1]: 'value1',
          };
          
          // 일반적인 방법으로 접근 불가
          console.log(obj['key1']); // undefined
          
          // Symbol을 직접 알고 있어야 접근 가능
          console.log(obj[sym1]); // 'value1'
          
          // 또는 Object.getOwnPropertySymbols로 모든 Symbol 키에 접근
          const symbols = Object.getOwnPropertySymbols(obj);
          console.log(obj[symbols[0]]); // 'value1'
          ```
          
  - **3. 협업과 유지보수**
      - 팀에서 협업할 때, `Symbol`을 통해 "숨겨진" 프로퍼티를 다른 개발자가 쉽게 찾지 못할 수 있다. → 코드의 의도를 이해하거나 문제를 해결하는 데 시간이 더 걸리게 할 수 있음
      - 시간이 지나면서 어떤 `Symbol`이 어떤 용도로 사용되었는지를 잊어버리거나 문서화가 부족할 경우 유지보수가 어려워질 수 있다.
  - **4. 해결책**
      - **명명된 `Symbol`**: `Symbol.for()`를 사용해 전역 심볼 레지스트리에서 관리되는 심볼을 사용하면, 동일한 `Symbol`을 여러 모듈에서 공유할 수 있지만 `Symbol`이 전역적으로 사용된다는 점에서 "숨김" 기능을 약화시킬 수 있다.
          
          ```jsx
          const sym1 = Symbol.for('sharedKey');
          const obj = {
            [sym1]: 'sharedValue',
          };
          
          // 다른 모듈에서도 같은 Symbol로 접근 가능
          const sym2 = Symbol.for('sharedKey');
          console.log(obj[sym2]); // 'sharedValue'
          ```
          
      - **명확한 문서화**: `Symbol`을 사용할 때는, 그 의도와 사용법을 명확히 문서화하고, 필요한 경우 적절한 이름을 붙여서 다른 개발자가 쉽게 이해할 수 있도록 해야 한다.
  
  **결론**
  
  - `Symbol`을 사용하여 프로퍼티를 "숨기는" 것은 강력한 방법이지만, 이러한 프로퍼티에 접근하려면 추가적인 메서드 사용이나 명시적인 관리가 필요하다.
  - 이를 적절히 사용하면 코드 보안을 강화할 수 있지만, 남용하거나 문서화 없이 사용하면 협업과 유지보수에서 불편함이 발생할 수 있다.
</details>
<br>
<br>

***Q***. 그럼 symbol을 사용할 때에는 이름을 명확히 하고 가능하면 description을 추가해서 console로 출력했을 때 어떤 값인지 알기 쉽게 하는 편이 좋겠네. 문서화까지 해두면 더 좋고?

***A***. YES
<details>
<summary>상세 답변</summary>
  
  `Symbol`을 사용할 때, 다음과 같은 방법으로 가독성과 유지보수성을 높이는 것이 좋습니다:
  
  - **1. 명확한 이름 사용**
      - `Symbol`을 생성할 때 해당 `Symbol`의 용도나 의미를 반영한 이름을 변수에 할당하는 것이 중요하다. → `Symbol`의 역할을 쉽게 이해할 수 있음
      
      ```jsx
      javascript코드 복사
      // 명확한 이름을 사용하여 Symbol 정의
      const userRoleSymbol = Symbol('userRole');
      const obj = {
        [userRoleSymbol]: 'admin',
      };
      ```
      
  - 2. **Description 추가**
      - `Symbol` 생성 시 설명(description)을 추가하여 콘솔 출력 시 `Symbol`의 의미를 알 수 있도록 하는 것이 좋다. → `description`은 `Symbol`의 디버깅과 로그 확인 시 유용
      
      ```jsx
      javascript코드 복사
      // Description을 추가한 Symbol 생성
      const userRoleSymbol = Symbol('userRole');
      console.log(userRoleSymbol); // Symbol(userRole)
      ```
      
      → 콘솔에서 `Symbol`을 출력할 때 의미를 알기 쉬워져 디버깅이나 코드 리뷰 시 도움이 됨
      
  - **3. 전역 Symbol 사용 고려 (`Symbol.for`)**
      - 만약 여러 모듈에서 동일한 `Symbol`을 공유해야 한다면 `Symbol.for()`를 사용하는 것도 한 방법이다. → 전역 심볼 레지스트리에서 관리, 동일한 키를 통해 동일한 `Symbol`을 여러 곳에서 사용 가능
      
      ```jsx
      javascript코드 복사
      // 전역 Symbol 생성
      const sharedSymbol = Symbol.for('sharedKey');
      
      // 다른 모듈에서도 동일한 Symbol을 사용할 수 있음
      const anotherSharedSymbol = Symbol.for('sharedKey');
      console.log(sharedSymbol === anotherSharedSymbol); // true
      ```
      
  - **4. 철저한 문서화**
      - `Symbol`을 사용하여 객체의 프로퍼티를 정의할 때는 해당 `Symbol`이 어떤 역할을 하는지 문서화해두는 것이 매우 중요하다.
      - 특히 팀 협업 시 `Symbol`이 어디서 사용되고 어떤 의미를 가지는지 명확히 설명해두면 다른 개발자가 코드를 이해하고 유지보수하는 데 큰 도움이 된다.
  - **5. Symbol과 객체 간 관계 명확화**
      - `Symbol`을 사용할 때, 해당 `Symbol`이 어떤 객체와 연관되어 있는지를 명확히 하기 위해 주석을 남기거나 관련된 코드를 근접하게 배치하는 것도 좋다.
  
  **결론**
  
  - `Symbol`을 사용할 때는 명확한 이름과 설명을 부여하여 가독성과 유지보수성을 높이고, 필요한 경우 문서화를 통해 협업과 장기적인 유지보수를 용이하게 해야 한다.
  - 이렇게 하면 `Symbol`이 제공하는 강력한 기능을 최대한 활용하면서도 코드의 복잡성을 관리하고 디버깅을 쉽게 할 수 있다.
</details>
<br>
<br>

***Q***. Symbol에서 new Symbol()을 지원하지 않는 이유는 뭐야? 항상 새로운 값이 생성된다는게 보장되기 때문이야?

***A***. 객체가 아니라 원시 타입이기 때문이다.
<details>
<summary>상세 답변</summary>
  
  `Symbol`에서 `new Symbol()`을 지원하지 않는 이유는 `Symbol`이 **원시 타입(primitive type)**이며, 고유한 식별자를 생성하는 데 목적이 있기 때문입니다. `Symbol`은 객체가 아니라 원시 타입이므로, `new` 키워드를 사용해 인스턴스를 생성할 필요가 없고, 실제로 그렇게 할 수 없습니다.
  
  - **1. 고유한 값 생성**
      - `Symbol()` 함수를 호출할 때마다 **항상** 새로운 고유한 `Symbol` 값이 생성된다. 이 값은 다른 어떤 `Symbol` 값과도 동일하지 않으며, 이 특성 덕분에 충돌 없이 객체의 프로퍼티 키로 사용할 수 있다.
      - `new` 키워드를 사용하지 않고도 고유한 값을 생성할 수 있기 때문에 `new Symbol()`을 지원할 필요가 없다.
      
      ```jsx
      javascript코드 복사
      const sym1 = Symbol('description');
      const sym2 = Symbol('description');
      
      console.log(sym1 === sym2); // false
      ```
      
      위 코드에서 `sym1`과 `sym2`는 동일한 설명을 가지고 있지만, 서로 다른 고유한 `Symbol` 값이다.
      
  - **2. 원시 타입**
      - `Symbol`은 `String`, `Number`, `Boolean`과 같은 원시 타입 중 하나로 설계되었다. 원시 타입은 `new` 키워드 없이도 값을 생성할 수 있다.
      - 원시 타입은 인스턴스화할 필요가 없는 간단한 데이터 타입이며 그 자체로 유효한 값이다. `Symbol`도 마찬가지로 객체처럼 인스턴스화할 필요가 없다.
      
  - **3. 불필요한 메모리 오버헤드 방지**
      - `new` 키워드를 사용해 객체를 생성하는 경우 메모리에서 새로운 객체가 할당된다. 그러나 `Symbol`은 고유 식별자를 단순히 생성하는 데 목적이 있기 때문에 불필요한 메모리 오버헤드를 피하기 위해 객체로 생성되지 않는다.
      - 이러한 설계는 메모리 효율성을 높이고 `Symbol`의 목적에 부합하게 만든다.
  - **4. API 설계 원칙**
      - 자바스크립트의 설계 철학 중 하나는 간단하고 일관된 API를 제공하는 것이다.
      - `Symbol`은 고유하고 변경 불가능한 값을 생성하기 위해 설계된 것이므로 이를 객체화할 이유가 없으며 따라서 API에서 `new Symbol()`을 금지한 것
  
  **결론**
  
  - `Symbol`은 고유한 식별자를 생성하기 위해 설계된 원시 타입이며, `new` 키워드를 사용할 필요가 없다.
  - `Symbol()`을 호출할 때마다 새로운 고유 값을 보장받기 때문에 굳이 객체로 인스턴스화할 필요가 없다.
  - 이는 메모리 효율성을 높이고 자바스크립트의 간단한 API 설계 원칙에 부합하는 방식이다.
</details>
</aside>
<br>

## ✨ 꼬리질문2 - JS 배열 메모리

<aside>

***Q***. js에서 배열은 연속된 메모리를 할당받아?

***A***. NO
<details>
<summary>상세 답변</summary>
  
  JavaScript에서 배열은 **연속된 메모리**를 할당받지 않습니다.
  
  JavaScript 배열은 사실 정통적인 배열과는 조금 다릅니다. 일반적인 저수준 언어(C, C++ 등)에서 배열은 연속된 메모리 블록을 할당받아 각 요소에 접근하는데 JavaScript에서는 배열이 연속된 메모리 블록으로 관리되지 않습니다. 대신 JavaScript 배열은 객체 형태로 구현되며 인덱스를 키로 사용하여 값을 저장하는 동적 리스트에 더 가깝습니다.
  
  이런 구조 덕분에 JavaScript 배열은 크기를 자유롭게 조정할 수 있고 중간에 빈 요소를 가질 수도 있습니다. 하지만 이러한 유연성 때문에 성능이 다소 희생될 수 있습니다. 특정 상황에서는 연속된 메모리 할당을 보장하는 **TypedArray**를 사용하는 것이 더 효율적일 수 있습니다.
  
  따라서 JavaScript 배열은 연속된 메모리를 할당받지 않으며 일반 객체처럼 동적으로 관리됩니다.
</details>
<br>
<br>

***Q***. TypedArray가 뭐야?

***A***. JavaScript 객체의 일종으로 연속된 메모리를 할당받아 요소에 빠르게 접근 가능해 성능이 중요한 작업에 유용하게 사용할 수 있다.
<details>
<summary>상세 답변</summary>
  
  `TypedArray`는 JavaScript에서 제공하는 객체로, **연속된 메모리 블록**에 저장된 데이터 요소들을 다루기 위한 배열 타입입니다. `TypedArray`는 동일한 데이터 타입의 요소들로만 구성되어 있으며, 숫자 데이터(정수, 부동소수점 수)를 효율적으로 처리하기 위해 설계되었습니다.
  
  - **주요 특징**
      - **고정된 크기**: `TypedArray`는 생성될 때 크기가 고정되며, 이후에는 변경할 수 없다.
      - **단일 데이터 타입**: 배열의 모든 요소는 동일한 데이터 타입을 가져야 한다.
      - **연속된 메모리 할당**: 모든 요소는 연속된 메모리 공간에 저장되어 있어 성능이 중요한 작업에 유리하다.
      - **빠른 접근 속도**: 연속된 메모리 덕분에 요소에 대한 접근 속도가 빠르다.
  - **`TypedArray`의 종류**
      
      JavaScript에는 다양한 `TypedArray`가 있으며 각기 다른 데이터 타입을 지원
      
      - `Int8Array`: 8비트 부호 있는 정수 (int8)
      - `Uint8Array`: 8비트 부호 없는 정수 (uint8)
      - `Uint8ClampedArray`: 8비트 부호 없는 정수(0~255 범위를 넘으면 자동으로 잘림)
      - `Int16Array`: 16비트 부호 있는 정수 (int16)
      - `Uint16Array`: 16비트 부호 없는 정수 (uint16)
      - `Int32Array`: 32비트 부호 있는 정수 (int32)
      - `Uint32Array`: 32비트 부호 없는 정수 (uint32)
      - `Float32Array`: 32비트 부동 소수점 수 (float32)
      - `Float64Array`: 64비트 부동 소수점 수 (float64)
  - **사용 예시**
      
      ```jsx
      javascript코드 복사
      // 8비트 부호 없는 정수 배열 생성
      let typedArray = new Uint8Array(4);
      
      // 배열에 값 할당
      typedArray[0] = 10;
      typedArray[1] = 20;
      typedArray[2] = 30;
      typedArray[3] = 40;
      
      console.log(typedArray); // Uint8Array(4) [ 10, 20, 30, 40 ]
      ```
      
      이 예시에서 `Uint8Array`는 4개의 8비트 부호 없는 정수로 구성된 배열을 생성하며 각 요소는 연속된 메모리에 저장
      
  - **용도**
      
      `TypedArray`는 주로 고성능이 필요한 애플리케이션에서 사용됩니다. 
      
      ex) 그래픽 처리, 게임 개발, 비디오 및 오디오 처리, WebAssembly와의 상호작용 등에서 자주 사용. 특히 이진 데이터(예: 파일에서 읽어들인 바이너리 데이터)를 다룰 때 유용
</details>
</aside>
<br>


## ✨ 추가질문1 - 강한참조 약한참조

<aside>

***Q***. JS에서 GC가 있잖아, 여기서 강한 참조와 약한 참조에 대한 개념이 사용되는 것 같은데 이걸 내부적으로 강한 참조인지 약한 참조인지 판단하는 어떤 기준이 있어?

***A***. 약한 참조는 특별한 컬렉션에 의해 생성되며 JS 엔진 내부에서 강한 참조만 카운팅하거나 마크하는 등의 방법으로 둘을 구분한다.
<details>
<summary>상세 답변</summary>
  
  JavaScript의 가비지 컬렉션(GC)에서 강한 참조와 약한 참조의 개념은 중요합니다. 내부적으로 강한 참조와 약한 참조를 구분하는 기준은 다음과 같습니다:
  
  - **1. 강한 참조 (Strong Reference):**
      - 일반적인 변수나 프로퍼티를 통해 객체를 참조하는 경우입니다.
      - 예: `let obj = {}`; `obj`는 객체에 대한 강한 참조입니다.
      - 강한 참조가 존재하는 한 해당 객체는 GC의 대상이 되지 않습니다.
  - **2. 약한 참조 (Weak Reference):**
      - `WeakMap`, `WeakSet` 등의 특별한 컬렉션을 통해 생성됩니다.
      - 약한 참조만 남아있다면 해당 객체는 GC의 대상이 될 수 있습니다.
  
  JavaScript 엔진은 다음과 같은 기준으로 참조를 판단합니다:
  
  - **1. 참조 타입:**
      - 일반 변수, 객체 프로퍼티, 배열 요소 등은 강한 참조로 취급됩니다.
      - `WeakMap`의 키, `WeakSet`의 값은 약한 참조로 취급됩니다.
  - **2. 도달 가능성 (Reachability):**
      - 루트(전역 객체, 현재 함수의 지역 변수 등)에서 시작하여 강한 참조를 따라 도달할 수 있는 객체는 "살아있는" 것으로 간주됩니다.
      - 오직 약한 참조만으로 도달 가능한 객체는 GC의 대상이 될 수 있습니다.
  - **3. 참조 카운팅:**
      - 일부 JavaScript 엔진은 참조 카운팅을 사용합니다. 강한 참조의 수를 세어 0이 되면 객체를 수집합니다.
      - 약한 참조는 이 카운트에 포함되지 않습니다.
  - **4. 마크-앤-스위프 (Mark-and-Sweep):**
      - 대부분의 최신 JavaScript 엔진에서 사용하는 알고리즘입니다.
      - 루트에서 시작하여 모든 강한 참조를 따라가며 도달 가능한 객체를 "마크"합니다.
      - 마크되지 않은 객체는 수집 대상이 됩니다.
  
  이러한 기준들을 통해 JavaScript 엔진은 내부적으로 강한 참조와 약한 참조를 구분하고, 가비지 컬렉션을 수행합니다.
</details>
<br>
<br>

***Q***. 그걸 저장하는 별도의 공간이 있는거야? 어떠한 값으로 갖고있어?

***A***. JS 엔진마다 다르지만 메모리 내에서 참조에 대한 정보를 특별한 방식으로 관리한다.
<details>
<summary>상세 답변</summary>
  
  JavaScript 엔진이 강한 참조와 약한 참조를 구분하는 방식에 대해 더 자세히 설명드리겠습니다.
  
  JavaScript 엔진은 일반적으로 객체와 그 참조에 대한 정보를 메모리 내에서 특별한 방식으로 관리합니다. 이는 엔진 구현에 따라 다를 수 있지만, 대체로 다음과 같은 방식을 사용합니다:
  
  - **1. 객체 메타데이터:**
      
      각 객체는 메모리에서 자신의 데이터 외에도 메타데이터를 가집니다. 이 메타데이터에는 참조 관련 정보가 포함될 수 있습니다.
      
  - **2. 참조 유형 플래그:**
      
      객체의 메타데이터나 참조 자체에 플래그를 사용하여 참조 유형을 표시할 수 있습니다. 예를 들어:
      
      - 0: 강한 참조
      - 1: 약한 참조
  - **3. 참조 테이블:**
      
      일부 엔진은 별도의 참조 테이블을 유지할 수 있습니다. 이 테이블에는 객체에 대한 참조와 그 유형이 저장됩니다.
      
  - **4. 객체 그래프:**
      
      메모리 내의 객체들과 그들 간의 참조 관계를 그래프 형태로 표현합니다. 이 그래프에서 엣지(edge)의 속성으로 참조 유형을 나타낼 수 있습니다.
      
  - **5. 비트 마킹:**
      
      객체 포인터의 하위 비트를 사용하여 참조 유형을 표시하는 방법도 있습니다. 대부분의 시스템에서 객체 주소는 word-aligned되어 있어 하위 비트가 항상 0입니다. 이 비트를 활용하여 참조 유형을 표시할 수 있습니다.
      
  - **6. WeakMap, WeakSet 구현:**
      
      `WeakMap`과 `WeakSet`은 내부적으로 특별한 자료구조를 사용하여 약한 참조를 구현합니다. 이들은 키나 값에 대한 참조를 약한 참조로 유지하면서도, 가비지 컬렉터와 협력하여 작동합니다.
      
  
  예를 들어, 간단화된 의사 코드로 나타내면 다음과 같을 수 있습니다:
  
  ```jsx
  class ObjectMetadata {
      constructor() {
          this.referenceType = ReferenceType.STRONG;
          this.referenceCount = 0;
      }
  }
  
  enum ReferenceType {
      STRONG,
      WEAK
  }
  
  // 객체 생성 시
  let obj = {};
  obj.__metadata = new ObjectMetadata();
  
  // 강한 참조 생성 시
  let strongRef = obj;
  obj.__metadata.referenceCount++;
  
  // 약한 참조 생성 시 (예: WeakMap에 추가)
  weakMap.set(obj, value);
  obj.__metadata.referenceType = ReferenceType.WEAK;
  ```
  
  이는 매우 단순화된 예시이며, 실제 구현은 훨씬 복잡하고 최적화되어 있습니다. 또한 정확한 구현 방식은 각 JavaScript 엔진(예: V8, SpiderMonkey, JavaScriptCore)마다 다를 수 있습니다.
</details>
</aside>